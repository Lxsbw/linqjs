// Generated by CoffeeScript 2.7.0
/*
  LINQ to CoffeeScript (Language Integrated Query)
*/
  /*
    Tool method
  */
var Linq, OrderedList, Tools;

Linq = (function() {
  class Linq {
    /*
      Defaults the elements of the list
    */
    constructor(elements = [], locales = null) {
      this._elements = elements;
      this._locales = locales;
    }

    /*
      Make the Linq iterable and Spreadable
    */
    * [Symbol.iterator]() {
      var element, j, len, ref, results;
      ref = this._elements;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        element = ref[j];
        results.push((yield element));
      }
      return results;
    }

    /*
      Adds an object to the end of the Linq<T>.
    */
    add(element) {
      return this._elements.push(element);
    }

    /*
      Appends an object to the end of the Linq<T>.
    */
    append(element) {
      return this.add(element);
    }

    /*
      Add an object to the start of the Linq<T>.
    */
    prepend(element) {
      return this._elements.unshift(element);
    }

    /*
      Adds the elements of the specified collection to the end of the Linq<T>.
    */
    addRange(elements) {
      _a;
      var _a;
      return (_a = this._elements).push.apply(_a, elements);
    }

    /*
      Applies an accumulator function over a sequence.
    */
    aggregate(accumulator, initialValue) {
      return this._elements.reduce(accumulator, initialValue);
    }

    /*
      Determines whether all elements of a sequence satisfy a condition.
    */
    all(predicate) {
      return this._elements.every(predicate);
    }

    /*
      Determines whether a sequence contains any elements.
    */
    any(predicate) {
      if (predicate) {
        return this._elements.some(predicate);
      } else {
        return this._elements.length > 0;
      }
    }

    /*
      Computes the average of a sequence of number values that are obtained by invoking
      a transform function on each element of the input sequence.
    */
    average(transform) {
      return Tools.calcNumDiv(this.sum(transform), this.count());
    }

    /*
      Casts the elements of a sequence to the specified type.
    */
    cast() {
      return new Linq(this._elements);
    }

    /*
      Removes all elements from the Linq<T>.
    */
    clear() {
      return this._elements.length = 0;
    }

    /*
      Concatenates two sequences.
    */
    concat(list) {
      return new Linq(this._elements.concat(list.toArray()));
    }

    /*
      Determines whether an element is in the Linq<T>.
    */
    contains(element) {
      return this.any(function(x) {
        return x === element;
      });
    }

    /*
      Returns the number of elements in a sequence.
    */
    count(predicate) {
      if (predicate) {
        return this.where(predicate).count();
      } else {
        return this._elements.length;
      }
    }

    /*
      Returns the elements of the specified sequence or the type parameter's default value
      in a singleton collection if the sequence is empty.
    */
    defaultIfEmpty(defaultValue) {
      if (this.count()) {
        return this;
      } else {
        return new Linq([defaultValue]);
      }
    }

    /*
      Returns distinct elements from a sequence by using the default equality comparer to compare values.
    */
    distinct() {
      return this.where(function(value, index, iter) {
        return (Tools.isObject(value) ? iter.findIndex(function(obj) {
          return Tools.equal(obj, value);
        }) : iter.indexOf(value)) === index;
      });
    }

    /*
      Returns distinct elements from a sequence according to specified key selector.
    */
    distinctBy(keySelector) {
      var func, groups;
      groups = this.groupBy(keySelector);
      func = function(res, key) {
        var curr;
        curr = new Linq(groups).firstOrDefault(function(x) {
          return Tools.equal(x.key, key);
        });
        res.add(curr.elements[0]);
        return res;
      };
      return new Linq(groups).select(function(x) {
        return x.key;
      }).toArray().reduce(func, new Linq());
    }

    /*
      Returns distinct elements from a sequence by using the default equality comparer to compare values and this select method.
    */
    distinctMap(predicate) {
      if (predicate) {
        return this.select(predicate).distinct();
      } else {
        return this.distinct();
      }
    }

    /*
      Returns the element at a specified index in a sequence.
    */
    elementAt(index) {
      if (index < this.count() && index >= 0) {
        return this._elements[index];
      } else {
        throw new Error('ArgumentOutOfRangeException: index is less than 0 or greater than or equal to the number of elements in source.');
      }
    }

    /*
      Returns the element at a specified index in a sequence or a default value if the index is out of range.
    */
    elementAtOrDefault(index) {
      if (index < this.count() && index >= 0) {
        return this._elements[index];
      } else {
        return null;
      }
    }

    /*
      Produces the set difference of two sequences by using the default equality comparer to compare values.
    */
    except(source) {
      return this.where(function(x) {
        return !source.contains(x);
      });
    }

    /*
      Returns the first element of a sequence.
    */
    first(predicate) {
      if (this.count()) {
        if (predicate) {
          return this.where(predicate).first();
        } else {
          return this._elements[0];
        }
      } else {
        throw new Error('InvalidOperationException: The source sequence is empty.');
      }
    }

    /*
      Returns the first element of a sequence, or a default value if the sequence contains no elements.
    */
    firstOrDefault(predicate) {
      if (this.count(predicate)) {
        return this.first(predicate);
      } else {
        return void 0;
      }
    }

    /*
      Performs the specified action on each element of the Linq<T>.
    */
    forEach(action) {
      return this._elements.forEach(action);
    }

    /*
      Groups the elements of a sequence according to a specified key selector function.
    */
    groupBy(grouper, mapper) {
      var element, group, groupMap, j, key, len, mappedValue, ref;
      if (mapper === void 0) {
        mapper = function(val) {
          return val;
        };
      }
      groupMap = new Map();
      ref = this._elements;
      for (j = 0, len = ref.length; j < len; j++) {
        element = ref[j];
        key = Tools.getHash(grouper(element));
        mappedValue = mapper(element);
        if (!groupMap.has(key)) {
          groupMap.set(key, {
            key: grouper(element),
            count: 0,
            elements: []
          });
        }
        group = groupMap.get(key);
        group.elements.push(mappedValue);
        group.count++;
      }
      return Array.from(groupMap.values());
    }

    /*
      Groups the elements of a sequence according to a specified key selector function.
      a little data.
    */
    groupByMini(grouper, mapper) {
      var func, initialValue;
      if (mapper === void 0) {
        mapper = function(val) {
          return val;
        };
      }
      initialValue = [];
      func = function(ac, v) {
        var existingGroup, existingMap, key, mappedValue;
        key = grouper(v);
        existingGroup = new Linq(ac).firstOrDefault(function(x) {
          return Tools.equal(x.key, key);
        });
        mappedValue = mapper(v);
        if (existingGroup) {
          existingGroup.elements.push(mappedValue);
          existingGroup.count++;
        } else {
          existingMap = {
            key: key,
            count: 1,
            elements: [mappedValue]
          };
          ac.push(existingMap);
        }
        return ac;
      };
      return this.aggregate(func, initialValue);
    }

    /*
      Correlates the elements of two sequences based on equality of keys and groups the results.
      The default equality comparer is used to compare keys.
    */
    groupJoin(list, key1, key2, result) {
      return this.select(function(x) {
        return result(x, list.where(function(z) {
          return key1(x) === key2(z);
        }));
      });
    }

    /*
      Returns the index of the first occurence of an element in the Linq.
    */
    indexOf(element) {
      return this._elements.indexOf(element);
    }

    /*
      Inserts an element into the Linq<T> at the specified index.
    */
    insert(index, element) {
      if (index < 0 || index > this._elements.length) {
        throw new Error('Index is out of range.');
      }
      return this._elements.splice(index, 0, element);
    }

    /*
      Produces the set intersection of two sequences by using the default equality comparer to compare values.
    */
    intersect(source) {
      return this.where(function(x) {
        return source.contains(x);
      });
    }

    /*
      Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.
    */
    join(list, key1, key2, result) {
      return this.selectMany(function(x) {
        return list.where(function(y) {
          return key2(y) === key1(x);
        }).select(function(z) {
          return result(x, z);
        });
      });
    }

    /*
      Returns the last element of a sequence.
    */
    last(predicate) {
      if (this.count()) {
        if (predicate) {
          return this.where(predicate).last();
        } else {
          return this._elements[this.count() - 1];
        }
      } else {
        throw Error('InvalidOperationException: The source sequence is empty.');
      }
    }

    /*
      Returns the last element of a sequence, or a default value if the sequence contains no elements.
    */
    lastOrDefault(predicate) {
      if (this.count(predicate)) {
        return this.last(predicate);
      } else {
        return void 0;
      }
    }

    /*
      Returns the maximum value in a generic sequence.
    */
    max(selector) {
      var identity;
      identity = function(x) {
        return x;
      };
      return Math.max.apply(Math, this._elements.map(selector || identity));
    }

    /*
      Returns the minimum value in a generic sequence.
    */
    min(selector) {
      var identity;
      identity = function(x) {
        return x;
      };
      return Math.min.apply(Math, this._elements.map(selector || identity));
    }

    /*
      Filters the elements of a sequence based on a specified type.
    */
    ofType(type) {
      typeName;
      var typeName;
      switch (type) {
        case Number:
          typeName = typeof 0;
          break;
        case String:
          typeName = typeof '';
          break;
        case Boolean:
          typeName = typeof true;
          break;
        case Function:
          typeName = typeof function() {}; // tslint:disable-line no-empty
          break;
        default:
          typeName = null;
          break;
      }
      if (typeName === null) {
        return this.where(function(x) {
          return x instanceof type;
        }).cast();
      } else {
        return this.where(function(x) {
          return typeof x === typeName;
        }).cast();
      }
    }

    /*
      Sorts the elements of a sequence in ascending order according to a key.
    */
    orderBy(keySelector, comparer) {
      if (comparer === void 0) {
        comparer = Tools.keyComparer(keySelector, false, this._locales);
      }
      // tslint:disable-next-line: no-use-before-declare
      return new OrderedList(Tools.arrayMap(this._elements), comparer, this._locales);
    }

    /*
      Sorts the elements of a sequence in descending order according to a key.
    */
    orderByDescending(keySelector, comparer) {
      if (comparer === void 0) {
        comparer = Tools.keyComparer(keySelector, true, this._locales);
      }
      // tslint:disable-next-line: no-use-before-declare
      return new OrderedList(Tools.arrayMap(this._elements), comparer, this._locales);
    }

    /*
      Performs a subsequent ordering of the elements in a sequence in
      ascending order according to a key.
    */
    thenBy(keySelector) {
      return this.orderBy(keySelector);
    }

    /*
      Performs a subsequent ordering of the elements in a sequence in
      descending order, according to a key.
    */
    thenByDescending(keySelector) {
      return this.orderByDescending(keySelector);
    }

    /*
      Removes the first occurrence of a specific object from the Linq<T>.
    */
    remove(element) {
      if (this.indexOf(element) !== -1) {
        this.removeAt(this.indexOf(element));
        return true;
      } else {
        return false;
      }
    }

    /*
      Removes all the elements that match the conditions defined by the specified predicate.
    */
    removeAll(predicate) {
      return this.where(Tools.negate(predicate));
    }

    /*
      Removes the element at the specified index of the Linq<T>.
    */
    removeAt(index) {
      return this._elements.splice(index, 1);
    }

    /*
      Reverses the order of the elements in the entire Linq<T>.
    */
    reverse() {
      return new Linq(this._elements.reverse());
    }

    /*
      Projects each element of a sequence into a new form.
    */
    select(selector) {
      return new Linq(this._elements.map(selector));
    }

    /*
      Projects each element of a sequence to a Linq<any> and flattens the resulting sequences into one sequence.
    */
    selectMany(selector) {
      return this.aggregate(((ac, _, i) => {
        ac.addRange(this.select(selector).elementAt(i).toArray());
        return ac;
      }), new Linq());
    }

    /*
      Determines whether two sequences are equal by comparing the elements by using the default equality comparer for their type.
    */
    sequenceEqual(list) {
      return this.all(function(e) {
        return list.contains(e);
      });
    }

    /*
      Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.
    */
    single(predicate) {
      if (this.count(predicate) !== 1) {
        throw new Error('The collection does not contain exactly one element.');
      } else {
        return this.first(predicate);
      }
    }

    /*
      Returns the only element of a sequence, or a default value if the sequence is empty;
      this method throws an exception if there is more than one element in the sequence.
    */
    singleOrDefault(predicate) {
      if (this.count(predicate)) {
        return this.single(predicate);
      } else {
        return void 0;
      }
    }

    /*
      Bypasses a specified number of elements in a sequence and then returns the remaining elements.
    */
    skip(amount) {
      return new Linq(this._elements.slice(Math.max(0, amount)));
    }

    /*
      Omit the last specified number of elements in a sequence and then returns the remaining elements.
    */
    skipLast(amount) {
      return new Linq(this._elements.slice(0, -Math.max(0, amount)));
    }

    /*
      Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
    */
    skipWhile(predicate) {
      return this.skip(this.aggregate((ac) => {
        if (predicate(this.elementAt(ac))) {
          return ++ac;
        } else {
          return ac;
        }
      }, 0));
    }

    /*
      Computes the sum of the sequence of number values that are obtained by invoking
      a transform function on each element of the input sequence.
    */
    sum(transform) {
      if (transform) {
        return this.select(transform).sum();
      } else {
        return this.aggregate((function(ac, v) {
          return (ac = Tools.calcNum(ac, +v));
        }), 0);
      }
    }

    /*
      Returns a specified number of contiguous elements from the start of a sequence.
    */
    take(amount) {
      return new Linq(this._elements.slice(0, Math.max(0, amount)));
    }

    /*
      Returns a specified number of contiguous elements from the end of a sequence.
    */
    takeLast(amount) {
      return new Linq(this._elements.slice(-Math.max(0, amount)));
    }

    /*
      Returns elements from a sequence as long as a specified condition is true.
    */
    takeWhile(predicate) {
      return this.take(this.aggregate((ac) => {
        if (predicate(this.elementAt(ac))) {
          return ++ac;
        } else {
          return ac;
        }
      }, 0));
    }

    /*
      Copies the elements of the Linq<T> to a new array.
    */
    toArray() {
      return this._elements;
    }

    /*
      Creates a Dictionary<TKey, TValue> from a Linq<T> according to a specified key selector function.
    */
    toDictionary(key, value) {
      return this.aggregate((dicc, v, i) => {
        // dicc[@select(key).elementAt(i).toString()] = if value then @select(value).elementAt(i) else v
        dicc.add({
          Key: this.select(key).elementAt(i),
          Value: value ? this.select(value).elementAt(i) : v
        });
        return dicc;
      }, new Linq());
    }

    /*
      Creates a Linq<T> from an Enumerable.Linq<T>.
    */
    toList() {
      return this;
    }

    /*
      Creates a Lookup<TKey, TElement> from an IEnumerable<T> according to specified key selector and element selector functions.
    */
    toLookup(keySelector, elementSelector) {
      return this.groupBy(keySelector, elementSelector);
    }

    /*
      Produces the set union of two sequences by using the default equality comparer.
    */
    union(list) {
      return this.concat(list).distinct();
    }

    /*
      Filters a sequence of values based on a predicate.
    */
    where(predicate) {
      return new Linq(this._elements.filter(predicate));
    }

    /*
      Applies a specified function to the corresponding elements of two sequences, producing a sequence of the results.
    */
    zip(list, result) {
      if (list.count() < this.count()) {
        return list.select((x, y) => {
          return result(this.elementAt(y), x);
        });
      } else {
        return this.select(function(x, y) {
          return result(x, list.elementAt(y));
        });
      }
    }

    /*
      Determine if two objects are equal.
    */
    // equals: (param1, param2) ->
    //   return Tools.equal(param1, param2)
    /*
      clone deep object.
    */
    cloneDeep(param) {
      return Tools.cloneDeep(param);
    }

  };

  /*
    property represents the Object name
  */
  Object.defineProperty(Linq.prototype, Symbol.toStringTag, {
    get: function() {
      return 'Linq';
    }
  });

  return Linq;

}).call(this);

/*
  Represents a sorted sequence. The methods of this class are implemented by using deferred execution.
  The immediate return value is an object that stores all the information that is required to perform the action.
  The query represented by this method is not executed until the object is enumerated either by
  calling its toDictionary, toLookup, toList or toArray methods
*/
OrderedList = class OrderedList extends Linq {
  constructor(elements, _comparer1, locales) {
    super(elements, locales);
    this._comparer = _comparer1;
    if (Tools.isArray(this._elements)) {
      this._elements.sort(this._comparer);
    }
  }

  /*
    Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.
    @override
  */
  thenBy(keySelector) {
    return new OrderedList(this._elements, Tools.composeComparers(this._comparer, Tools.keyComparer(keySelector, false), this._locales), this._locales);
  }

  /*
    Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.
    @override
  */
  thenByDescending(keySelector) {
    return new OrderedList(this._elements, Tools.composeComparers(this._comparer, Tools.keyComparer(keySelector, true), this._locales), this._locales);
  }

};

Tools = {
  /*
    Checks if the argument passed is an object
  */
  isObject: function(x) {
    return !!x && typeof x === 'object';
  },
  /*
    Determine if two objects are equal
  */
  equal: function(a, b) {
    var Fn, entriesA, entriesB, types;
    if (a === b) {
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (!this.isObject(a) || !this.isObject(b)) {
      return a === b;
    }
    types = [a, b].map(function(x) {
      return x.constructor;
    });
    if (types[0] !== types[1]) {
      return false;
    }
    if (a instanceof Date && b instanceof Date) {
      return a.getTime() === b.getTime();
    }
    if (a instanceof RegExp && b instanceof RegExp) {
      return a.toString() === b.toString();
    }
    entriesA = Object.entries(a);
    entriesB = Object.entries(b);
    if (entriesA.length !== entriesB.length) {
      return false;
    }
    Fn = (entries, _b) => {
      return entries.every(([key, val]) => {
        if (this.isObject(val)) {
          return this.equal(_b[key], val);
        } else {
          return _b[key] === val;
        }
      });
    };
    return Fn(entriesA, b) && Fn(entriesB, a);
  },
  /*
    Creates a function that negates the result of the predicate
  */
  negate: function(pred) {
    return function() {
      var _i, args;
      args = [];
      for (_i in arguments) {
        args[_i] = arguments[_i];
      }
      return !pred.apply(void 0, args);
    };
  },
  /*
    Comparer helpers
  */
  composeComparers: function(previousComparer, currentComparer) {
    return function(a, b) {
      return previousComparer(a, b) || currentComparer(a, b);
    };
  },
  /*
    Key comparer
  */
  keyComparer: function(_keySelector, descending, locales) {
    var _comparer, _stringComparer;
    // common comparer
    _comparer = function(sortKeyA, sortKeyB) {
      if (sortKeyA > sortKeyB) {
        if (!descending) {
          return 1;
        } else {
          return -1;
        }
      } else if (sortKeyA < sortKeyB) {
        if (!descending) {
          return -1;
        } else {
          return 1;
        }
      } else {
        return 0;
      }
    };
    // string comparer
    _stringComparer = function(sortKeyA, sortKeyB) {
      if (locales) {
        if (sortKeyA.localeCompare(sortKeyB, locales) > 0) {
          if (!descending) {
            return 1;
          } else {
            return -1;
          }
        } else if (sortKeyB.localeCompare(sortKeyA, locales) > 0) {
          if (!descending) {
            return -1;
          } else {
            return 1;
          }
        } else {
          return 0;
        }
      } else {
        if (sortKeyA.localeCompare(sortKeyB) > 0) {
          if (!descending) {
            return 1;
          } else {
            return -1;
          }
        } else if (sortKeyB.localeCompare(sortKeyA) > 0) {
          if (!descending) {
            return -1;
          } else {
            return 1;
          }
        } else {
          return 0;
        }
      }
    };
    return (a, b) => {
      var sortKeyA, sortKeyB;
      sortKeyA = _keySelector(a);
      sortKeyB = _keySelector(b);
      if (this.isString(sortKeyA) && this.isString(sortKeyB)) {
        return _stringComparer(sortKeyA, sortKeyB);
      }
      return _comparer(sortKeyA, sortKeyB);
    };
  },
  /*
    Number calculate addition
  */
  calcNum: function(num1, num2) {
    var mult, place;
    if ((!this.isNum(num1)) || (!this.isNum(num2))) {
      return 0;
    }
    ({mult, place} = this.calcMultiple(num1, num2));
    return Number(((num1 * mult + num2 * mult) / mult).toFixed(place));
  },
  /*
    Number calculate division
  */
  calcNumDiv: function(num1, num2) {
    var mult;
    if ((!this.isNum(num1)) || (!this.isNum(num2))) {
      return 0;
    }
    ({mult} = this.calcMultiple(num1, num2));
    return (num1 * mult) / (num2 * mult);
  },
  /*
    Check number
  */
  isNum: function(args) {
    return (typeof args === 'number') && (!isNaN(args));
  },
  /*
    Check string
  */
  isString: function(args) {
    return (typeof args === 'string') && (args.constructor === String);
  },
  /*
    Check array
  */
  isArray: function(array) {
    return Array.isArray(array);
  },
  /*
    Calculation multiple
  */
  calcMultiple: function(num1, num2) {
    var arrNum1, arrNum2, mult, place, sq1, sq2;
    arrNum1 = num1.toString().split('.');
    arrNum2 = num2.toString().split('.');
    sq1 = arrNum1.length > 1 ? arrNum1[1].length : 0;
    sq2 = arrNum2.length > 1 ? arrNum2[1].length : 0;
    mult = Math.pow(10, Math.max(sq1, sq2));
    place = sq1 >= sq2 ? sq1 : sq2;
    return {mult, place};
  },
  /*
    Build array new reference
  */
  arrayMap: function(array) {
    if (!this.isArray(array)) {
      return array;
    }
    return array.map(function(x) {
      return x;
    });
  },
  /*
    Clone data
  */
  cloneDeep: function(obj) {
    var k, o, result, v;
    if (typeof structuredClone === 'function') {
      return structuredClone(obj);
    }
    if (null === obj || "object" !== typeof obj) {
      // Handle the 3 simple types, and null or undefined
      return obj;
    }
    // Handle Date
    if (obj instanceof Date) {
      result = new Date();
      result.setTime(obj.getTime());
      return result;
    }
    // Handle RegExp
    if (obj instanceof RegExp) {
      result = obj;
      return result;
    }
    // Handle Array
    if (obj instanceof Array) {
      result = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = obj.length; j < len; j++) {
          o = obj[j];
          results.push(this.cloneDeep(o));
        }
        return results;
      }).call(this);
      return result;
    }
    // Handle Object
    if (obj instanceof Object) {
      result = {};
      for (k in obj) {
        v = obj[k];
        if (obj.hasOwnProperty(k)) {
          result[k] = this.cloneDeep(v);
        }
      }
      return result;
    }
    throw new Error("Unable to copy param! Its type isn't supported.");
  },
  /*
    Generate Hash
  */
  getHash: function(obj) {
    var generateHash, hashValue, typeOf;
    hashValue = '';
    typeOf = function(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
    };
    generateHash = function(value) {
      var keys, type;
      type = typeOf(value);
      switch (type) {
        case 'object':
          keys = Object.keys(value).sort();
          keys.forEach(function(key) {
            return hashValue += `${key}:${generateHash(value[key])};`;
          });
          break;
        case 'array':
          value.forEach(function(item) {
            return hashValue += `${generateHash(item)},`;
          });
          break;
        case 'boolean':
          hashValue += `boolean<>_<>_<>${value.toString()}`;
          break;
        case 'null':
          hashValue += 'null<>_<>_<>';
          break;
        case 'undefined':
          hashValue += 'undefined<>_<>_<>';
          break;
        default:
          hashValue += value ? value.toString() : '';
      }
      return hashValue;
    };
    return generateHash(obj);
  }
};

// ###
//   property represents the Object name
// ###
// Object.defineProperty Linq::, Symbol.toStringTag,
//   get: ->
//     'Linq'
module.exports = Linq;
